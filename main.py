
# Steg 1
# Logiken
# Istället för att be användaren om en nyckel, ska ditt program:
# 1. Ta emot ett krypterat meddelande.
# 2. Loopa igenom alla möjliga nycklar (från 0 till längden av SYMBOLS ).
# 3. För varje nyckel, anropa din befintliga funktion translate_message i läget "decrypt".
# 4. Skriva ut resultatet för varje försök så att en människa kan läsa och se när texten blir
# begriplig.

# Steg 2
# 1. Skapa en lista med vanliga svenska ord (t.ex. ["OCH", "DET", "ATT", "I", "EN", "JAG"] ).
# 2. För varje brute force-försök:
# Dela upp det dekrypterade meddelandet i en lista av ord (använd .split() ). Skapa en "poängräknare" (score).
# Loopa igenom orden i meddelandet och kontrollera om de finns i ditt lexikon.
# Om ett ord finns i lexikonet, öka poängen.
# 3. Spara det försök som fick högst poäng och presentera det som det mest troliga svaret.


from cipher_utils import decryption_candidates

SWEDISH_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ"

# List generated by Google Gemini.
SWEDISH_WORDS = (
    "och", "i", "att", "en", "jag", "hon", "han", "på", "är", "det",
    "vi", "de", "som", "med", "för", "har", "till", "av", "om", "inte",
    "den", "ett", "men", "var", "skall", "nu", "eller", "säger", "kan",
    "man", "skulle", "efter", "vid", "från", "ut", "upp", "när", "ut",
    "över", "under", "också", "får", "kunde", "måste"
)

if __name__ == "__main__":

    print("Encrypted Caesar Cipher Message:")
    cc_msg = input("> ")

    candidates = decryption_candidates(cc_msg, SWEDISH_ALPHABET)
    for key, text in candidates:
        print(f"Key: {key}, Text: {text}")

